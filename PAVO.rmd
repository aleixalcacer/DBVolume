---
title: "Density Based Volume Estimation"
output: 
  html_document
---

```{r setup, include=FALSE}
library(tidyverse)
```


# Example 01

```{r}
# Load points 01

# Load csv file from desktop in Windows
# data <- read_csv2("C:/Users/aalcacer/Desktop/TCSArcalis.csv")
# data <- read_csv2("C:/Users/aalcacer/Desktop/TCSTlepidus_m.csv")
# data <- read_csv2("C:/Users/aalcacer/Desktop/TCSPionicus.csv")

# Remove the first column
# points_01 <- data[, -1]

# n <- 10
# points_01_1 <- matrix(
#   c(
#     runif(n, min = 0, max = 1),
#     runif(n, min = 0, max = 1),
#     runif(n, min = 0, max = 1)
#   ),
#   ncol = 3
# )

# # Add extremes of the cube
# points_01_1 <- rbind(points_01_1, matrix(c(0, 0, 0), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(0, 0, 1), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(0, 1, 0), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(0, 1, 1), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(1, 0, 0), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(1, 0, 1), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(1, 1, 0), ncol = 3))
# points_01_1 <- rbind(points_01_1, matrix(c(1, 1, 1), ncol = 3))


# points_01_2 <- matrix(
#   c(
#     runif(n, min = 2, max = 3),
#     runif(n, min = 0, max = 1),
#     runif(n, min = 0, max = 1)
#   ),
#   ncol = 3
# )

# # Add extremes of the cube
# points_01_2 <- rbind(points_01_2, matrix(c(2, 0, 0), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(2, 0, 1), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(2, 1, 0), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(2, 1, 1), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(3, 0, 0), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(3, 0, 1), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(3, 1, 0), ncol = 3))
# points_01_2 <- rbind(points_01_2, matrix(c(3, 1, 1), ncol = 3))


# points_01 <- rbind(points_01_1, points_01_2)

colnames(points_01) <- c("x", "y", "z")
```

```{r}
# Load points 02

# Load file from desktop in Windows
# data <- read_csv2("C:/Users/aalcacer/Desktop/TCSOlot.csv")
# data <- read_csv2("C:/Users/aalcacer/Desktop/TCSTlepidus_f.csv")
# data <- read_csv2("C:/Users/aalcacer/Desktop/TCSTPpeloponnesiacus.csv")

# Remove the first column
# points_02 <- data[, -1]

# n <- 10
# n2 <- 1000

# points_02_1 <- matrix(
#   c(
#     runif(n, min = 1, max = 2),
#     runif(n, min = -1, max = 0),
#     runif(n, min = 0, max = 1)
#   ),
#   ncol = 3
# )
# # Add extremes of the cube
# points_02_1 <- rbind(points_02_1, matrix(c(1, -1, 0), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(1, -1, 1), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(1, 0, 0), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(1, 0, 1), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(2, -1, 0), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(2, -1, 1), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(2, 0, 0), ncol = 3))
# points_02_1 <- rbind(points_02_1, matrix(c(2, 0, 1), ncol = 3))

# points_02_2 <- matrix(
#   c(
#     runif(n, min = 1, max = 2),
#     runif(n, min = 1, max = 2),
#     runif(n, min = 0, max = 1)
#   ),
#   ncol = 3
# )

# # Add extremes of the cube
# points_02_2 <- rbind(points_02_2, matrix(c(1, 1, 0), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(1, 1, 1), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(1, 2, 0), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(1, 2, 1), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(2, 1, 0), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(2, 1, 1), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(2, 2, 0), ncol = 3))
# points_02_2 <- rbind(points_02_2, matrix(c(2, 2, 1), ncol = 3))


# points_02_3 <- matrix(
#   c(
#     runif(n2, min = 1 + 1e-3, max = 2),
#     runif(n2, min = 1 + 1e-3, max = 1 + 2 * 1e-3),
#     runif(n2, min = 0 + 1e-3, max = 1)
#   ),
#   ncol = 3
# )

# points_02 <- rbind(points_02_1, points_02_2, points_02_3)

colnames(points_02) <- c("x", "y", "z")
```


```{r}
volume_square <- function(ch, points, sigma = 1) {
    points <- as.matrix(points)
    n <- nrow(points)
    sigma <- sigma / 2
    points_hull <- ch$p[unique(c(ch$hull)), ]
    v <- c()
    for (i in 1:n) {
        points_i <- array(0, dim = c(8, 3))
        # Print first row of points_i array

        points_i[1, ] <- points[i, ] + c(-sigma, -sigma, -sigma)
        points_i[2, ] <- points[i, ] + c(-sigma, -sigma, sigma)
        points_i[3, ] <- points[i, ] + c(-sigma, sigma, -sigma)
        points_i[4, ] <- points[i, ] + c(-sigma, sigma, sigma)
        points_i[5, ] <- points[i, ] + c(sigma, -sigma, -sigma)
        points_i[6, ] <- points[i, ] + c(sigma, -sigma, sigma)
        points_i[7, ] <- points[i, ] + c(sigma, sigma, -sigma)
        points_i[8, ] <- points[i, ] + c(sigma, sigma, sigma)

        convhull <- geometry::intersectn(points_hull, points_i)
        vol <- convhull$ch$vol
        v <- c(v, vol)
    }
    v / (n * (2 * sigma)^3) # Normalize by the number of points and the volume of the cube
}


calculate_sigmas <- function(sigma_min, sigma_max, n = 10) {
  sigma_min <- log10(sigma_min)
  sigma_max <- log10(sigma_max)

  10 ^ seq(sigma_min, sigma_max, length.out = n)
}

# define simpson integration function
simpson <- function(x, y) {
  if (length(x) != length(y)) {
    stop("x and y must be the same length")
  }
  if (length(x) < 3) {
    stop("x and y must have at least 3 elements")
  }
  if (any(diff(x) <= 0)) {
    stop("x must be strictly increasing")
  }
  if (any(abs(diff(diff(x))) > 1e-10)) {
    stop("x must be equally spaced")
  }

  h <- diff(x)
  len_y <- length(y)
  integral_value <- (h[1] / 3) * (y[1] + 4 * sum(y[seq(2, len_y, by = 2)]) + 2 * sum(y[seq(3, len_y - 1, by = 2)]) + y[len_y])
  integral_value / (x[len_y] - x[1])
}

volume_overlap <- function(points_a, points_b, sigma = NULL, n_sigma = 5) {
    convhull <- geometry::intersectn(points_a, points_b)
    ch_a <- convhull$ch1
    ch_b <- convhull$ch2
    ch_i <- convhull$ch

    points_u <- rbind(points_a, points_b)

    if (is.null(sigma)) {
        sigma_max <- max(points_u) - min(points_u)
        sigma_min <- 1e-4
        sigmas <- calculate_sigmas(sigma_min, sigma_max, n = n_sigma)

        v_i <- c()
        v_a <- c()
        v_b <- c()
        v_u <- c()
        vboth <- c()
        vsmallest <- c()

        for (sigma in sigmas) {
          v_i_i <- sum(volume_square(ch_i, points_u, sigma = sigma))
          v_a_i <- sum(volume_square(ch_a, points_u, sigma = sigma))
          v_b_i <- sum(volume_square(ch_b, points_u, sigma = sigma))
          v_u_i <- v_a_i + v_b_i - v_i_i
          vboth_i <- v_i_i / v_u_i
          vsmallest_i <- v_i_i / min(v_a_i, v_b_i)

          v_i <- c(v_i, v_i_i)
          v_a <- c(v_a, v_a_i)
          v_b <- c(v_b, v_b_i)
          v_u <- c(v_u, v_u_i)
          vboth <- c(vboth, vboth_i)
          vsmallest <- c(vsmallest, vsmallest_i)
        }

        sigmas <- log10(sigmas)
        v_i <- simpson(sigmas, v_i)
        v_a <- simpson(sigmas, v_a)
        v_b <- simpson(sigmas, v_b)
        v_u <- simpson(sigmas, v_u)
        vboth <- simpson(sigmas, vboth)
        vsmallest <- simpson(sigmas, vsmallest)

        df <- data.frame(
          va = v_a,
          vb = v_b,
          vu = v_u,
          vboth = vboth,
          vsmallest = vsmallest
        )
        return(df)
    }

    v_i <- sum(volume_square(ch_i, points_u, sigma = sigma))
    v_a <- sum(volume_square(ch_a, points_u, sigma = sigma))
    v_b <- sum(volume_square(ch_b, points_u, sigma = sigma))

    v_u <- v_a + v_b - v_i

    vboth <- v_i / v_u
    vsmallest <- v_i / min(v_a, v_b)

    df <- data.frame(
      va = v_a,
      vb = v_b,
      vi = v_i,
      vu = v_u,
      vboth = vboth,
      vsmallest = vsmallest
    )
    return(df)
}

```

```{r}
# Compute de Volume

# Compute the volume for different values of sigma
# and store it in a Data Frame with columns (method, sigma, volume)
volumes <- NULL
volume_density_null <- volume_overlap(points_01, points_02, sigma = NULL)$vboth

for (param in c(1e-2, 1e-1, 1, 4)) {
  volume_density <- volume_overlap(points_01, points_02, sigma = param)$vboth

  volume_i <- tibble(method = "volDENSITY", param = param, volume = volume_density)
  volumes <- bind_rows(volumes, volume_i)

  volume_i <- tibble(method = "volDENSITY_AUTO", param = param, volume = volume_density_null)
  volumes <- bind_rows(volumes, volume_i)
}
```
  
```{r}
for (param in c(1e-2, 1e-1, 1, 4)) {
  volume_alpha_null <- pavo::voloverlap(points_01, points_02,
                  type = "alpha", nsamp = 1e6, avalue = "auto")$pboth

  volume_i <- tibble(method = "volALPHA_AUTO", param = param, volume = volume_alpha_null)
  volumes <- bind_rows(volumes, volume_i)

  volume_alpha <- pavo::voloverlap(points_01, points_02,
                  type = "alpha", nsamp = 1e6, avalue = param)$pboth

  volume_i <- tibble(method = "volALPHA", param = param, volume = volume_alpha)
  volumes <- bind_rows(volumes, volume_i)
}
```

```{r}
for (param in c(1e-2, 1e-1, 1, 4)) {
  volume_convex <- pavo::voloverlap(points_01, points_02,
                   type = "convex")$vboth
  volume_i <- tibble(method = "volCONVEX", param = param, volume = volume_convex)
  volumes <- bind_rows(volumes, volume_i)
}
```


```{r}
# Plot the results
volumes_plot <- volumes
p <- ggplot(volumes_plot, aes(x = param, y = volume, color = method)) +
  geom_point() +
  geom_line() +
  # scale_x_log10() +
  labs(x = "Sigma/Alpha", y = "Volume", color = "Method")

p

# ggsave("C:/Users/aalcacer/Desktop/volums_2.png", p, width = 10, height = 6)
```


```{r}
# Plot points_01 data using plotly 3d scater plot

# Load plotly library
library(plotly)

# Create a 3d scatter plot
p <- plot_ly() # Add a second 3d scatter plot
p <- p %>% add_trace(type="scatter3d", data=as.tibble(points_01), x=~x, y=~y, z=~z, mode="markers", marker=list(size=2, color="green"))
p <- p %>% add_trace(type="scatter3d", data=as.tibble(points_02), x=~x, y=~y, z=~z, mode="markers", marker=list(size=2, color="red"))
p <- p %>% add_trace(type="mesh3d", data=as_tibble(points_01), x=~x, y=~y, z=~z, opacity=0.1, alphahull=0)
p <- p %>% add_trace(type="mesh3d", data=as_tibble(points_02), x=~x, y=~y, z=~z, opacity=0.1, alphahull=0)
p <- p %>% hide_guides()

p
```